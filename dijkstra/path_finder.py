import sys
import pprint
from dijkstra import dijkstra, shortest_path
sys.path.append('../spoon-master/test/block')
from block_parser import parseCFG

def cfg_to_graph(cfg_file):
    """Input: a list of nodes parsed by parseCFG from parser.
       Output: a graph that can be parsed by dijkstra, of the form:
       { 0: {1: 1, 2: 1},
         1: {3: 1},
         2: {3, 1},
         3: {4, 1},
         4: {},
         5: {6: 1},
         6: {}
       }
       such that each nodenum is a key in a dictionary, and the value
       is a dictionary where the keys are the nodes from which there
       is an edge between the original node and this node, and the
       values are all 1 (representing edge weight 1)"""

    parsed_cfg = parseCFG(cfg_file)

    graph = {}
    for node in parsed_cfg:
        nodenum = int(node[0].rstrip(' loop'))
        graph[nodenum] = {}

        successors = node[6].split(',')
        for successor in successors:
            if len(successor.strip()) > 0: # skip ' ', ''
                successor = int(successor)
                graph[nodenum][successor] = 1

    return graph

def get_path_if_exists(graph, start, end):
    """Returns the path in list form (empty if path does not exist)"""
    try:
        dist,pred = dijkstra(graph, start=start, end=end)
        #print "Successfully found path from %s to %s:" % (start, end)
        #print dist, pred
        return (start, end, pred)
    except KeyError:
        #print "No path exists from %s to %s." % (start, end)
        return (start, end, {})

def find_all_paths(cfg_file, sources, sinks):
    """Returns a list of all paths (in list form from get_path_if_exists)
       from sources to sinks in this cfg.  Paths are in the form 'pred'
       (as the output of dijkstra) such that a path 5->6->10 is returned
       as the dictionary {10: 6, 6: 5}"""
    graph = cfg_to_graph(cfg_file)
    paths = []
    for source in sources:
        for sink in sinks:
            path = get_path_if_exists(graph, source, sink)
            if len(path[2]) > 0:
                paths.append(path)
    return paths

#TEST_CFG_FILE = '../spoon-master/test/CFG_files/afalkcagoidkdjdlfoaicbanbfgoamoo/script.js.cfg'
#print find_all_paths(TEST_CFG_FILE, [1,5], [7,8,9,10])


