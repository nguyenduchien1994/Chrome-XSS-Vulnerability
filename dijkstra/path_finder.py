from dijkstra import dijkstra, shortest_path
from block_parser import parseCFG

TEST_CFG_FILE = "/Users/firechant/Projects/Chrome-XSS-Vulnerability/spoon-master/test/CFG_files/cfidkbgamfhdgmedldkagjopnbobdmdn/app.js.cfg"
#TODO: this particular CFG wants to start at 1.....
# perhaps we want to start at first block that has successors?

#TODO: import source/sink list finder
def get_sinks():
    return [2,4,5]
def get_sources():
    return [1,4]

def cfg_to_graph(cfg_file):
    """Input: a list of nodes parsed by parseCFG from parser.
       Output: a graph that can be parsed by dijkstra, of the form:
       { 0: {1: 1, 2: 1},
         1: {3: 1},
         2: {3, 1},
         3: {4, 1},
         4: {},
         5: {6: 1},
         6: {}
       }
       such that each nodenum is a key in a dictionary, and the value
       is a dictionary where the keys are the nodes from which there
       is an edge between the original node and this node, and the
       values are all 1 (representing edge weight 1)"""

    parsed_cfg = parseCFG(cfg_file)

    graph = {}
    for node in parsed_cfg:
        nodenum = int(node[0].rstrip(' loop'))
        graph[nodenum] = {}

        successors = node[6].split(',')
        for successor in successors:
            if len(successor.strip()) > 0: # skip ' ', ''
                successor = int(successor)
                graph[nodenum][successor] = 1

    return graph

def path_exists(graph, start, end):
    """Returns True if there is a path from start to end in the graph,
       False otherwise"""
    try:
        dist,pred = dijkstra(graph, start=start, end=end)
        print "Successfully found path from %s to %s:" % (start, end)
        print dist, pred
        return True
    except KeyError:
        print "No path exists from %s to %s." % (start, end)
        return False

graph = cfg_to_graph(TEST_CFG_FILE)
assert(path_exists(graph, 1, 8))
assert(False == path_exists(graph, 1, 85))

